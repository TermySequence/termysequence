// Copyright Â© 2018 TermySequence LLC
//
// SPDX-License-Identifier: GPL-2.0-only

#include "common.h"
#include "app/attrbase.h"
#include "workmodel.h"
#include "iconmodel.h"
#include "viewitem.h"
#include "settings.h"
#include "status.h"
#include "window.h"

#include <QHeaderView>
#include <QMenu>
#include <QResizeEvent>
#include <QIcon>
#include <QHash>
#include <QSet>
#include <QFileInfo>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <cstdio>
#include <cerrno>

#define WORK_COLUMN_MACRO 0
#define WORK_COLUMN_NAME 1
#define WORK_COLUMN_ICON 2
#define WORK_N_COLUMNS   3

WorkModel *g_workmodel;
WorkFilter *g_workfilter;
WorkView *g_workview;

static QRegularExpression s_re(A("^#define (ICON_\\S+).*?\"(\\S+)(\"\\S*)(?:.*// (\\S+))?"));

#define SH_MAINLOOP "# Generated by " ICONTOOL_NAME " " PROJECT_VERSION \
    "\n\nfor subdir in [0-9]*; do\n" \
    "dest=\"$1/$subdir\"\n" \
    "mkdir -p \"$dest\" || return 1\n\n"

#define SH_SVGLOOP "\nfor subdir in [0-9]*; do\n" \
    "dest=\"$2/$subdir\"\n" \
    "mkdir -p \"$dest\" || return 1"

#define SH_ENDLOOP "\ndone\n"

struct WorkRecord
{
    QString macro;
    QString name;
    QString key;
    QString glob;
    QIcon icon;
};

struct InstallRecord {
    QString dest;
    QSet<int> sizes;
    int size;
    bool failed;
    QHash<QByteArray,QString> hashes;
    QStringList sizedSvg;
    QStringList unsizedSvg;
    QString home;

    bool (*copy_func)(InstallRecord*, const IconRecord*, QString, const char*);
    bool (*link_func)(InstallRecord*, const char*, const char*);

    FILE *distfh;
    FILE *instfh;
};

static void
updateSearchGlob(WorkRecord *rec)
{
    QStringList list({ rec->macro, rec->name, rec->key });
    rec->glob = list.join('\x1f');
}

static bool
RecordSorter(const WorkRecord *a, const WorkRecord *b)
{
    return a->name < b->name;
}

WorkModel::WorkModel(QObject *parent) :
    QAbstractTableModel(parent),
    m_path(g_settings->workfile())
{
    QRegularExpressionMatch match;
    char buf[4096] = {};

    FILE *fh = fopen(pr(m_path), "re");
    if (!fh) {
        fprintf(stderr, "Error: rules file %s not found\n", pr(m_path));
        exit(2);
    }
    while (fgets(buf, sizeof(buf) - 1, fh)) {
        if ((match = s_re.match(buf)).hasMatch()) {
            WorkRecord *rec = new WorkRecord;
            rec->macro = match.captured(1);
            rec->name = match.captured(2);
            rec->key = match.captured(4);
            updateSearchGlob(rec);
            m_list.append(rec);
        }
    }
    fclose(fh);
    connect(g_iconmodel, SIGNAL(loaded()), SLOT(handleIconsLoaded()));
}

void
WorkModel::handleIconsLoaded()
{
    for (auto *rec: qAsConst(m_list))
        rec->icon = g_iconmodel->lookupIcon(rec->key);

    g_status->log(L("loaded %1 definitions from %2").arg(m_list.size()).arg(m_path));
}

WorkModel::~WorkModel()
{
    forDeleteAll(m_list);
}

void
WorkModel::save()
{
    QRegularExpressionMatch match;
    char buf[4096] = {};
    QByteArray tmpfile = (m_path + ICONTOOL_NAME "~").toUtf8();
    int keycol = g_settings->keycol();
    FILE *ih, *oh;

    ih = fopen(pr(m_path), "re");
    if (!ih)
        goto err;
    oh = fopen(tmpfile.data(), "we");
    if (!oh)
        goto err2;

    while (fgets(buf, sizeof(buf) - 1, ih)) {
        QString line(buf);
        if (line.endsWith('\n'))
            line.chop(1);
        if ((match = s_re.match(line)).hasMatch()) {
            QString name = match.captured(2);

            for (const auto *rec: qAsConst(m_list)) {
                if (rec->name == name) {
                    line.resize(match.capturedEnd(3));
                    if (!rec->key.isEmpty()) {
                        line = line.leftJustified(keycol) + A("// ") + rec->key;
                    }
                    break;
                }
            }
        }
        fprintf(oh, "%s\n", pr(line));
    }
    fclose(ih);
    fclose(oh);

    if (rename(tmpfile.data(), pr(m_path)) != 0) {
        g_status->log(A("rename failed during save: ") + strerror(errno), 2);
        unlink(tmpfile.data());
    }
    return;
err2:
    fclose(ih);
err:
    g_status->log(L("open failed during save: ") + strerror(errno), 2);
}

static QByteArray
getHash(const QString &path)
{
    char buf[PATH_MAX] = {};
    QString cmd = L("/usr/bin/sha1sum '%1'").arg(path);
    FILE *ph = popen(pr(cmd), "re");
    fgets(buf, sizeof(buf) - 1, ph);
    pclose(ph);

    int size = 40;
    if (strlen(buf) < size || strspn(buf, "0123456789abcdefABCDEF") < size)
        size = 0;
    return QByteArray(buf, size);
}

bool
WorkModel::doHelper(const WorkRecord *rec, InstallRecord *irec) const
{
    if (rec->key.isEmpty())
        return true;

    const auto *theirs = g_iconmodel->lookup(rec->key);
    if (!theirs) {
        g_status->log(L("no icon found for key '%1'").arg(rec->key), 2);
        return false;
    }

    QString to = rec->name + A(".png");
    QString from = theirs->pathfmt.arg(irec->size);
    QByteArray hash = getHash(from);

    if (hash.isEmpty()) {
        g_status->log(L("failed to get hash for %1").arg(from), 2);
        return false;
    }

    auto i = irec->hashes.constFind(hash);
    if (i == irec->hashes.cend()) {
        irec->hashes.insert(hash, to);
        return (*irec->copy_func)(irec, theirs, from, pr(to));
    } else {
        return (*irec->link_func)(irec, pr(*i), pr(to));
    }
}

static bool
fileCopy(InstallRecord *irec, const IconRecord *, QString from, const char *to)
{
    int ifd, ofd;
    char buf[65536], *ptr;

    ifd = open(pr(from), O_RDONLY|O_CLOEXEC);
    if (ifd == -1)
        goto err;
    ofd = open(pr(irec->dest + to), O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
    if (ofd == -1)
        goto err2;

    while (true) {
        ssize_t total = read(ifd, buf, sizeof(buf));
        if (total == 0)
            break;
        if (total < 0)
            goto err3;

        ptr = buf;
        while (total) {
            ssize_t sent = write(ofd, ptr, total);
            if (sent <= 0)
                goto err3;
            ptr += sent;
            total -= sent;
        }
    }

    close(ofd);
    close(ifd);
    return true;
err3:
    close(ofd);
err2:
    close(ifd);
err:
    g_status->log(L("file copy of %1 to %2 failed").arg(from, to), 2);
    return false;
}

static bool
fileLink(InstallRecord *irec, const char *from, const char *to)
{
    if (chdir(pr(irec->dest)) != 0) {
        g_status->log(L("chdir to %1 failed: %1").arg(strerror(errno)), 2);
        return false;
    }

    unlink(to);
    if (symlink(from, to) != 0) {
        g_status->log(L("link of %1 to %2 failed: %3").arg(from, to, strerror(errno)), 2);
        return false;
    }
    return true;
}

bool
WorkModel::writeIndex(InstallRecord *irec) const
{
    QString path = irec->dest + A("/index.theme");
    FILE *fh = fopen(pr(path), "we");
    if (!fh) {
        g_status->log(L("failed to open %1: %2").arg(path, strerror(errno)), 2);
        return false;
    }

    fputs("[Icon Theme]\nName=" APP_NAME "\nComment=" APP_NAME " icons\n\n", fh);
    fputs("Directories=", fh);

    auto i = irec->sizes.cbegin(), j = irec->sizes.cend();
    while (1) {
        fprintf(fh, "%dx%d", *i, *i);
        if (++i == j)
            break;
        fputc(',', fh);
    }

    fputc('\n', fh);

    i = irec->sizes.cbegin();
    while (i != j) {
        fprintf(fh, "\n[%dx%d]\nSize=%d\n", *i, *i, *i);
        ++i;
    }

    fclose(fh);
    return true;
}

void
WorkModel::doInstall(IconThread *thread) const
{
    g_status->log(A("started install operation"));
    InstallRecord irec{};
    system(pr(L("/bin/mkdir -p '%1'").arg(m_target)));
    bool rc = true;

    auto sorted = m_list;
    std::sort(sorted.begin(), sorted.end(), RecordSorter);
    irec.copy_func = &fileCopy;
    irec.link_func = &fileLink;
    irec.sizes = g_settings->sizes();
    irec.sizes.insert(16);

    for (int size: irec.sizes) {
        irec.dest = L("%1/%2x%2").arg(m_target).arg(size);
        irec.size = size;
        mkdir(pr(irec.dest), 0755);
        irec.dest += '/';
        irec.hashes.clear();

        for (const auto *rec: sorted) {
            thread->incProgress();
            if (!doHelper(rec, &irec)) {
                rc = false;
                break;
            }
        }
    }
    chdir(pr(g_settings->repo()));
    irec.dest = m_target;
    if (rc && writeIndex(&irec))
        g_status->log(A("finished install operation (success)"));
    else
        g_status->log(A("finished install operation (failure)"));
}

void
WorkModel::makeInstall()
{
    bool ok;
    m_target = getInput(A("Perform a local installation of the current icon theme to:"),
                        g_settings->installdir(), &ok);
    if (ok) {
        auto *thread = new IconThread(this, this, 3);
        unsigned total = (g_settings->sizes().size() + 1) * rowCount();
        thread->setMsg(L("Installing %2 of %1").arg(total));
        connect(thread, SIGNAL(finished()), SIGNAL(finished()));
        thread->start();
    }
}

static void
findSvg(const IconRecord *theirs, InstallRecord *irec)
{
    QString path = theirs->pathfmt;
    path.replace(A("/%1x%1/"), A("/scalable/"));
    path.chop(4);
    path.append(A(".svgz"));
    QFileInfo fi(path);
    QString cmd = L("find %1 -name %2.svgz -print").arg(fi.path(), theirs->name);
    QStringList results;
    char buf[PATH_MAX] = {};
    FILE *ph = popen(pr(cmd), "re");

    while (fgets(buf, sizeof(buf) - 1, ph)) {
        QString result(buf);
        if (result.endsWith('\n')) result.chop(1);
        results.append(result);
    }
    fclose(ph);

    for (const QString &result: results) {
        if (result == path) {
            path.replace(irec->home, A("$HOME"));
            irec->unsizedSvg += L("cp \"%1\" \"$2\"").arg(path);
            return;
        }
    }

    QString pat = L("/%2x%2/%1.svgz").arg(theirs->name);
    bool rc = true;

    for (int size: irec->sizes) {
        QString str = pat.arg(size);
        for (const QString &result: results) {
            if (result.endsWith(str)) {
                str = result;
                str.replace(irec->home, A("$HOME"));
                irec->sizedSvg += L("cp \"%1\" \"$dest\"").arg(str);
                goto next;
            }
        }
        rc = false;
    next:;
    }

    if (!rc)
        g_status->log(L("warning: missing SVG file(s) for %1").arg(theirs->key), 1);
}

static bool
updateCopy(InstallRecord *irec, const IconRecord *theirs, QString from, const char *to)
{
    fprintf(irec->instfh, "install -m 644 $subdir/%s \"$dest\"\n", to);

    if (theirs->source != ABBREV_NAME) {
        if (theirs->needsvg)
            findSvg(theirs, irec);

        from.replace(A("/16x16/"), A("/$subdir/"));
        from.replace(irec->home, A("$HOME"));
        fprintf(irec->distfh, "cp \"%s\" \"$dest/%s\"\n", pr(from), to);
    }

    return true;
}

static bool
updateLink(InstallRecord *irec, const char *from, const char *to)
{
    fprintf(irec->instfh, "(cd \"$dest\" && ln -sf %s %s)\n", from, to);
    return true;
}

void
WorkModel::doUpdate(IconThread *thread) const
{
    g_status->log(A("started update operation"));
    InstallRecord irec{};
    bool rc = true;

    auto sorted = m_list;
    std::sort(sorted.begin(), sorted.end(), RecordSorter);
    irec.copy_func = &updateCopy;
    irec.link_func = &updateLink;
    irec.sizes = g_settings->sizes();
    irec.sizes.insert(16);
    irec.size = 16;
    irec.dest = m_target;
    irec.home = getenv("HOME");

    if (!(irec.instfh = fopen(pr(m_target + A("/install.sh")), "we")))
        goto err2;
    if (!(irec.distfh = fopen(pr(m_target + A("/dist.sh")), "we")))
        goto err3;

    fputs(SH_MAINLOOP, irec.instfh);
    fputs(SH_MAINLOOP, irec.distfh);
    for (const auto *rec: sorted) {
        thread->incProgress();
        if (!doHelper(rec, &irec)) {
            rc = false;
            break;
        }
    }
    fputs(SH_ENDLOOP, irec.instfh);
    fputs(SH_ENDLOOP, irec.distfh);

    fputs(SH_SVGLOOP, irec.distfh);
    fputs(SH_ENDLOOP, irec.distfh);

    std::sort(irec.sizedSvg.begin(), irec.sizedSvg.end());
    fprintf(irec.distfh, "\n%s\n", pr(irec.sizedSvg.join('\n')));

    std::sort(irec.unsizedSvg.begin(), irec.unsizedSvg.end());
    fprintf(irec.distfh, "\n%s\n", pr(irec.unsizedSvg.join('\n')));

    fclose(irec.distfh);
    fclose(irec.instfh);
    if (!rc)
        goto err;

    g_status->log(A("finished update operation (success)"));
    return;
err3:
    g_status->log(L("failed to open dist.sh: %1").arg(strerror(errno)), 2);
    fclose(irec.instfh);
err2:
    g_status->log(L("failed to open install.sh: %1").arg(strerror(errno)), 2);
err:
    g_status->log(A("finished update operation (failure)"));
}

void
WorkModel::makeUpdate()
{
    bool ok;
    m_target = getInput(A("Update the install scripts in the icon theme source repository:"),
                        g_settings->distdir(), &ok);
    if (ok) {
        auto *thread = new IconThread(this, this, 2);
        thread->setMsg(L("Updating %2 of %1").arg(rowCount()));
        connect(thread, SIGNAL(finished()), SIGNAL(finished()));
        thread->start();
    }
}

void
WorkModel::run(IconThread *thread)
{
    switch (thread->type()) {
    case 2:
        doUpdate(thread);
        break;
    case 3:
        doInstall(thread);
        break;
    }
}

void
WorkModel::setIcon(int row, const QString &key)
{
    auto *rec = m_list.value(row);
    if (rec) {
        rec->key = key;
        rec->icon = g_iconmodel->lookupIcon(rec->key);
        updateSearchGlob(rec);

        QModelIndex start = createIndex(row, 0);
        QModelIndex end = createIndex(row, WORK_N_COLUMNS - 1);
        emit dataChanged(start, end);
    }
}

/*
 * Model functions
 */
int
WorkModel::columnCount(const QModelIndex &parent) const
{
    return WORK_N_COLUMNS;
}

int
WorkModel::rowCount(const QModelIndex &parent) const
{
    return m_list.size();
}

QModelIndex
WorkModel::index(int row, int column, const QModelIndex &) const
{
    if (row >= 0 && row < m_list.size())
        return createIndex(row, column, (void*)m_list.at(row));
    else
        return QModelIndex();
}

QVariant
WorkModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    return QVariant();
}

QVariant
WorkModel::data(const QModelIndex &index, int role) const
{
    const auto *rec = (const WorkRecord *)index.internalPointer();
    if (rec)
        switch (index.column()) {
        case WORK_COLUMN_MACRO:
            if (role == Qt::DisplayRole)
                return rec->macro;
            break;
        case WORK_COLUMN_NAME:
            if (role == Qt::DisplayRole)
                return rec->name;
            break;
        case WORK_COLUMN_ICON:
            switch (role) {
            case Qt::DisplayRole:
                return rec->key;
            case Qt::DecorationRole:
                return rec->icon;
            }
            break;
        }

    return QVariant();
}

Qt::ItemFlags
WorkModel::flags(const QModelIndex &index) const
{
    return Qt::ItemIsSelectable | Qt::ItemIsEnabled;
}

//
// Filter
//
WorkFilter::WorkFilter(QObject *parent) :
    QSortFilterProxyModel(parent)
{
    setDynamicSortFilter(false);
    setSourceModel(g_workmodel);
}

void
WorkFilter::setSearch(const QString &search)
{
    m_search = search;
    invalidateFilter();
}

bool
WorkFilter::filterAcceptsRow(int row, const QModelIndex &parent) const
{
    QModelIndex index = g_workmodel->index(row, 0, parent);
    const auto *rec = (const WorkRecord *)index.internalPointer();
    return rec && rec->glob.contains(m_search, Qt::CaseInsensitive);
}

//
// View
//
WorkView::WorkView()
{
    QItemSelectionModel *m = selectionModel();
    setModel(g_workfilter);
    delete m;

    setShowGrid(false);
    setSelectionBehavior(QAbstractItemView::SelectRows);
    setSelectionMode(QAbstractItemView::ExtendedSelection);
    verticalHeader()->setVisible(false);
    horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    horizontalHeader()->setVisible(false);

    setItemDelegate(new WorkItemDelegate(this));
    resizeRowsToContents();
    resizeColumnsToContents();
}

void
WorkView::setIcon()
{
    auto theirs = g_iconview->selectionModel()->selectedIndexes();
    auto ours = selectionModel()->selectedRows();
    if (!theirs.isEmpty() && !ours.isEmpty()) {
        const auto *rec = (const IconRecord *)theirs.at(0).internalPointer();
        if (rec) {
            for (auto &index: ours) {
                auto source = g_workfilter->mapToSource(index);
                g_workmodel->setIcon(source.row(), rec->key);
            }
        }
    }
}

void
WorkView::unsetIcon()
{
    for (auto &index: selectionModel()->selectedRows()) {
        auto source = g_workfilter->mapToSource(index);
        g_workmodel->setIcon(source.row(), g_mtstr);
    }
}

void
WorkView::contextMenuEvent(QContextMenuEvent *event)
{
    QMenu *menu = new QMenu(this);
    menu->addAction(A("Set Icon"), this, &WorkView::setIcon);
    menu->addAction(A("Clear Icon"), this, &WorkView::unsetIcon);

    menu->popup(event->globalPos());
    event->accept();
}
